commands:
  - name: "clone"
    short: "clone a git repo from account"
    args:
      - name: name
        usage: "repository name"
        required: true
    flags:
      - name: email
        usage: "signature email"
        required: false
        default: "realfabecker@outlook.com"
      - name: account
        usage: "github account url"
        required: false
        default: git@realfabecker.github.com:realfabecker
    cmd: |
      set -e

      echo "Cloning git repository from account...."
      git clone {{ .GetFlag "account" }}/{{ .GetArg "name" }}.git

      echo "Configuring git commit signature..."
      (cd {{ .GetArg "name" }} && kevin gpg git {{ .GetFlag "email" }})
    shell: "/bin/bash"

  - name: "repo"
    short: "interface de manutenção repositórios"
    commands:
      - name: "fetch"
        short: "fetch repositories from a account"
        flags:
          - name: owner
            usage: "repository owner"
            required: true
          - name: token
            usage: "github token"
            required: true
        # language=typescript
        cmd: |
          import * as fs from "node:fs";
          import * as path from "node:path";
          import * as os from "node:os";

          async function* paginateRepositoriesFromGithubApi(opts: {
            token: string;
            url: string;
            start_page: number;
            per_page: number;
          }) {
            let page: number | null = opts.start_page;

            do {
              console.log(`url=${opts.url} page=${page}`);
              const response = await fetch(
                `${opts.url}?page=${page}&per_page=${opts.per_page}`,
                {
                  headers: {
                    Authorization: `Bearer ${opts.token}`,
                  },
                }
              );

              const data = await response.json();
              if (Array.isArray(data) && data.length) {
                yield* data;
              }

              const r = response?.headers
                ?.get("link")
                ?.match(
                  /<https.*page\=(\d+)&per_page\=(\d+).*rel\="next"/
                );

              page = (r?.[1] ?? null) as number | null;
            } while (page);
          }

          async function readReposIntoLocalJsonFile(opts: {
            owner: string;
            token: string;
          }) {
            const filePath = path.join(import.meta.dirname, "repos.json");
            if (fs.existsSync(filePath)) fs.rmSync(filePath);

            const writeStream = fs.createWriteStream(filePath);
            writeStream.write("[" + os.EOL);
            for await (const x of paginateRepositoriesFromGithubApi({
              url: `https://api.github.com/orgs/${opts.owner}/repos`,
              token: opts.token,
              start_page: 1,
              per_page: 100,
            })) {
              writeStream.write(JSON.stringify({ name: x.name }) + "," + os.EOL);
            }
            writeStream.write("]" + os.EOL);
          }

          await readReposIntoLocalJsonFile({
            owner: `{{ .GetFlag "owner" }}`,
            token: `{{ .GetFlag "token" }}`,
          });

      - name: "put"
        short: "put repository element"
        flags:
          - name: owner
            usage: "repository owner"
            required: true
          - name: repo
            usage: "repository name"
            required: true
          - name: elem
            usage: "repository elem"
            required: true
          - name: token
            usage: "github token"
            required: true    
        #language=typescript
        cmd: |   
          import * as fs from "node:fs";
          import * as path from "node:path";

          async function sendElemPutRequest(opts: {
            url: string;
            token: string;
            body: Record<string, any>;
          }) {
            const response = await fetch(opts.url, {
              method: "POST",
              body: JSON.stringify(opts.body),
              headers: {
                Authorization: `Bearer ${opts.token}`,
              },
            });
            if (response.status !== 201) {
              const responseBody = await response.json();
              throw new Error(`Github Error: ${JSON.stringify({ responseBody })}`);
            }
          }

          function readElemListFromFile(elem: string): Record<string, any>[] {
            const filePath = path.join(
              import.meta.dirname,
              "src",
              "assets",
              `${elem}.json`
            );
            const fileData = fs.readFileSync(filePath, { encoding: "utf8" });
            return JSON.parse(fileData);
          }

          async function putRepositoryElem(opts: {
            owner: string;
            repo: string;
            token: string;
            elem: string;
          }) {
            for (const item of readElemListFromFile(opts.elem)) {
              try {
                await sendElemPutRequest({
                  url: `https://api.github.com/repos/${opts.owner}/${opts.repo}/${opts.elem}`,
                  body: item,
                  token: opts.token,
                });
                console.log(
                  `level="info" repo="${opts.repo}" elem="${item.name}" message="Success"`
                );
              } catch (e) {
                console.log(
                  `level="error" repo="${opts.repo}" elem="${item.name}" message="${
                    (<Error>e).message
                  }"`
                );
              }
            }
          }      
          await putRepositoryElem({
            owner: `{{ .GetFlag "owner" }}`,
            repo: `{{ .GetFlag "repo" }}`,
            elem: `{{ .GetFlag "elem" }}`,
            token: `{{ .GetFlag "token" }}`,
          });

  - name: "hotfix"
    short: "manutenção de branchs em contexto de hotfix"
    commands:
      - name: "branch"
        short: "manutenção de branch de hotfix"
        commands: 
          - name: "create"
            short: "cria a branch para contexto de hotfix"
            args:
              - name: name
                usage: "nome do branch a ser criado a partir do hotfix"
                required: true
            cmd: |
              set -e

              echo "[INF] Consultando os releases do projeto..."
              release_date=$(git branch -r --list "origin/release-*26" | grep -v $(date +'%d%m%y') | sed -s -E 's/origin\/release\-([0-9]{2})([0-9]{2})([0-9]{2})/20\3-\2-\1/g' | sort -r | awk 'NR==1' | xargs -I{} date -d {} +'%d%m%y')

              if [[ -z $release_date ]]; then
                echo "[ERR] Não é possível criar a branch. A branch release não existe"
              fi;"

              echo "[INF] Obtendo referencias da branch base origin/release-$release_date..."
              git fetch --quiet origin "release-$release_date"

              hotfix_branch="release-$release_date-{{ .GetArg "name" }}"

              echo "[INF] Checando se a branch já não existe na origem $hotfix_branch..."
              if [[ -n $(git ls-remote --quiet --heads --no-refs origin "$hotfix_branch") ]]; then
                echo "[ERR] Não é possível criar a branch $branch_name pois elá já existe na origem remota"
                exit 0
              fi;

              echo "[INF] Criando a branch $hotfix_branch..."
              git checkout -b $hotfix_branch -t "origin/release-$release_date"

              echo "[INF] Publicando a branch $hotfix_branch no remoto..."
              git push -u origin $hotfix_branch
        
      - name: "pr"
        short: "operaçõse de pull request de hotfix"
        commands:
          - name: "create"
            short: "Cria as pull request para o pr hotfix"
            cmd: |     
              set -e 

              if ! git branch --show-current | grep -E release-[0-9]{6} -q; then 
                  echo "[ERR] Não é possível criar o pull request. A branch deve ser prefixada com release-"
                  exit 0
              fi

              out="Os seguintes Pull Requests foram criados para liberação:\n"

              if [[ -n $(git branch -r --list origin/develop) ]]; then
                echo "[INF] Criando pull request para o ambiente develop..."
                dev=$(gh pr create --base develop --fill-first | grep https)
                out+=" --> Develop: $dev\n"
              else 
                echo "[WRN] Não é possível criar o pull request. A branch develop não existe"
              fi

              if [[ -n $(git branch -r --list origin/master) ]]; then
                echo "[INF] Criando pull request para o ambiente master..."
                mas=$(gh pr create --base master --fill-first | grep https)
                out+=" --> Master: $mas\n"
              else 
                echo "[WRN] Não é possível criar o pull request. A branch master não existe"
              fi

              release_date=$(git branch -r --list "origin/release-*26" | sed -s -E 's/origin\/release\-([0-9]{2})([0-9]{2})([0-9]{2})/20\3-\2-\1/g' | sort -r | awk 'NR==1' | xargs -I{} date -d {} +'%d%m%y')
              if [[ -n $release_date ]]; then 
                echo "[INF] Criando pull request para o ambiente release-$release_date..."
                rel=$(gh pr create --base "release-$release_date" --fill-first | grep https)
                out+=" --> Release: $rel\n"
              else 
                echo "[WRN] Não é possível criar o pull request. A branch release não existe"
              fi

              echo -e "$out"
